# -*- coding: utf-8 -*-
"""RFM_analysis_project_EN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RweahKZDCafy5nqu9EsfmL0kLyl9fx_w

# STEP 1: DATA PREVIEW AND CLEANING

## Step 1.1: Load the library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt

!pip install squarify
import squarify

from google.colab import drive
drive.mount('/content/drive')

"""## Step 1.2: Load the csv"""

ecom_url = '/content/drive/MyDrive/Google Colab CSV/ecommerce-retail.csv'
# Read data frame from CSV file
ecom = pd.read_csv(ecom_url)
ecom

"""## Step 1.3: Check dataset info"""

ecom.info()

"""## Step 1.4: Check and clean columns that have null values
We found out that CustomerID column has null values in this case, let fix it in the next steps
"""

# Check null info
ecom.isnull().any()

# Drop null
ecom = ecom.dropna(subset=['CustomerID'])
ecom

# Check null info again
ecom.isnull().any()

"""## Step 1.5: Check data description and clean (if needed)
Check whether the data consists of any outliers
"""

ecom.describe()

"""Look like there is a negative min Quantity and UnitPrice equals to 0, which is not appropriate in this case. Let's exclude it."""

# Include rows from Quantity and UnitPrice column that are positive only
ecom = ecom[(ecom['Quantity'] > 0) & (ecom['UnitPrice'] > 0)]
ecom.describe()

"""# STEP 2: DATA WRANGLING

## Step 2.1: Filter columns required for analysis
"""

ecom = ecom[['CustomerID','InvoiceDate','InvoiceNo','Quantity','UnitPrice']]
ecom.head()

"""## Step 2.2: Calculate total value of each invoice"""

ecom["TotalRevenue"] = ecom["Quantity"] * ecom["UnitPrice"]
ecom.head()

"""## Step 2.3: Turn InvoiceDate, CustomerID to right format"""

ecom['InvoiceDate'] = pd.to_datetime(ecom['InvoiceDate'])
ecom['CustomerID'] = ecom['CustomerID'].astype(str)
ecom

"""# STEP 3: RFM CALCULATION

## Step 3.1: Calculate recency, monetary and frequency values group by CustomerID
"""

ecom_rfm = ecom.groupby("CustomerID").agg(
    {
        "InvoiceDate": lambda date: (dt.datetime(2011, 12, 31) - date.max()).days,
        "TotalRevenue": "sum",
        "InvoiceNo": "count",
    }
)

ecom_rfm

"""## Step 3.2: Change column names for clarity"""

new_ecom_rfm = ecom_rfm.rename(
    columns={
        "InvoiceDate": "Recency",
        "TotalRevenue": "Monetary",
        "InvoiceNo": "Frequency",
    }
)
new_ecom_rfm

"""## Step 3.3: Calcute RFM score based on quantile"""

def calculate_rfm_scores(data):
    # Calculate RFM scores using qcut with 5 labels
    data['R'] = pd.qcut(data['Recency'], q=5, labels=[5, 4, 3, 2, 1])
    data['F'] = pd.qcut(data['Frequency'], q=5, labels=[1, 2, 3, 4, 5])
    data['M'] = pd.qcut(data['Monetary'], q=5, labels=[1, 2, 3, 4, 5])

    # Calculate overall RFM score
    data['RFMScore'] = data['R'].astype(str) + data['F'].astype(str) + data['M'].astype(str)
    data['RFMScore'] = data['RFMScore'].astype(int)
    return data


new_ecom_rfm = calculate_rfm_scores(new_ecom_rfm)
new_ecom_rfm

"""## Step 3.4: Segment the customers based on their RFM Scores"""

# Read the segment file
segment = pd.read_excel('/content/drive/MyDrive/Google Colab CSV/ecommerce retail.xlsx', sheet_name = 1)

# Split the RFM Score column into each row
segment['RFM Score'] = segment['RFM Score'].str.split(',')
segment = segment.explode('RFM Score').reset_index(drop=True)
segment['RFM Score']=segment['RFM Score'].astype(int)
segment.sort_values(by='RFM Score')

# Join the segment table with new_ecom_rfm table with left join
new_ecom_rfm = new_ecom_rfm.merge(segment,how = 'left', left_on = 'RFMScore',right_on ='RFM Score')
new_ecom_rfm = new_ecom_rfm.dropna()
new_ecom_rfm

"""# STEP 4: VISUALIZATION & RECOMMENDATION

## Step 4.1: Visualize distribution of RFM
"""

# Set the style and color palette
sns.set_style('whitegrid')
palette_color = ['#ff9999', '#66b3ff', '#99ff99', '#ffcc99']

# Create a figure with three subplots
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# Plot the distribution of Recency
sns.histplot(new_ecom_rfm['R'], ax=axes[0], bins=5, color=palette_color[0])
axes[0].set_title('Distribution of Recency')
axes[0].set_xlabel('')
axes[0].set_ylabel('Count')

# Plot the distribution of Frequency
sns.histplot(new_ecom_rfm['F'], ax=axes[1], bins=5, color=palette_color[1])
axes[1].set_title('Distribution of Frequency')
axes[1].set_xlabel('')
axes[1].set_ylabel('')


# Plot the distribution of Monetary
sns.histplot(new_ecom_rfm['M'], ax=axes[2], bins=5, color=palette_color[2])
axes[2].set_title('Distribution of Monetary')
axes[2].set_xlabel('')
axes[2].set_ylabel('')


# Display the plot
plt.show()

"""## Step 4.2: Visualize treemap of RFM"""

colors = ['#91DCEA', '#64CDCC','#F6511D','#FFB400','#7FB800','#F7EF99','#5D675B','#F5F3F5','#9593D9','#F7E1D7','#00C49A']
fig, ax = plt.subplots(1, figsize=(15,8))
# Calculate the portion of each segment
segment_counts = new_ecom_rfm['Segment'].value_counts()
portion = segment_counts / segment_counts.sum()

# Calculate the percentage for each segment and round it to 1-2 decimal points
percentage = portion * 100.0
percentage = percentage.round(2)

# Create labels with segment names and percentages
labels = [f"{segment}\n{percent:.2f}%" for segment, percent in zip(segment_counts.index, percentage)]

# Create the treemap
squarify.plot(sizes=percentage,
              label=labels,
              color=colors[:len(segment_counts)],
              alpha=0.6,
              bar_kwargs=dict(linewidth=2.4, edgecolor="white"),
              )


plt.title("Customer Segments Based on RFM Score",
          fontsize=16,
          pad=8,
          fontweight='bold'
)
plt.axis('off')
plt.show()

"""## Step 4.3: Recommendation

"""

recommendation = {
    'Segment Name': [
        'Hibernating customers (18.63%)', 'Champions (18.42%)', 'Potential Loyalist (11.85%)', 'At Risk (9.98%)',
        'Lost customers (9.77%)', 'Loyal (9.64%)', 'New Customers (6.98%)', 'Need Attention (5.23%)',
        'About To Sleep (4.40%)', 'Promising (3.09%)', 'Cannot Lose Them (2.01%)'
    ],
    'Characteristics': [
        'Low recency, low frequency, low monetary',
        'High recency, high frequency, high monetary',
        'Medium recency, medium frequency, medium monetary',
        'High recency, low frequency, high monetary',
        'Very low recency, low frequency, low monetary',
        'High recency, high frequency, high monetary',
        'High recency, low frequency, low monetary',
        'Medium recency, medium frequency, medium monetary',
        'Low recency, low frequency, low monetary',
        'High recency, low frequency, medium monetary',
        'Low recency, low frequency, high monetary'
    ],
    'Recommendations': [
        'Reactivate with targeted campaigns to this segment since it takes the most portion',
        'Reward loyalty, upsell, cross-sell more to this segment since it takes the second place',
        'Nurture with personalized offers, this segment takes top 3',
        'Engage to prevent churn, top 4 in the portion should not be overlooked',
        'Winback with attractive offers with the top 5 segment',
        'Maintain satisfaction, upsell, cross-sell',
        'Welcome and onboard effectively',
        'Provide incentives to increase purchases',
        'Reactivate before they churn',
        'Convert to loyal customers',
        'Retain with exceptional service'
    ]
}

# Create the DataFrame
recommendation = pd.DataFrame(recommendation)
recommendation

"""# Conclusion

Overall, the correlation between the three RFM (Recency, Frequency, Monetary) metrics is very evident in this case. If one of the three indicators is positive, it tends to positively influence the other two, and vice versa. In addition, the distribution of these three indicators is quite balanced, showing that the customer base of the business is evenly spread across different segments.

Here are some suggestions to further develop the top customer groups of SuperStore:

**Champions Group:** Focus on maintaining engagement with this group by offering continuous incentives. Provide them with specially tailored promotions to encourage regular purchases.

**Potential Loyalists Group:** Encourage this group to make repeat purchases so that they can be converted into Champions. Since the RFM metrics are closely related, positively influencing just the Recency or Frequency score (e.g., through attractive offers, exciting events, or excellent customer service) will likely also improve the Monetary score and the remaining metric.

**Hibernating Customers Group:** Reactivate their purchasing behavior through promotions, marketing efforts, and omnichannel sales strategies. The aim is to rebuild their awareness of the brand’s products and new offers. Gradually develop the relationship with these customers so that they become frequent buyers. This group typically does not spend a large amount in a single transaction, so it requires patience to build a long-term buying connection.

Lastly, other customer segments should not be neglected. The goal is to get them to engage in regular and continuous purchases over time, which will have a significant impact on the company’s revenue. For the Marketing department, it is recommended to create truly compelling and trend-driven campaigns (e.g., videos, quizzes, etc.) to boost conversions.
"""