# -*- coding: utf-8 -*-
"""Nguyen_QuocTrieu_RFM_analysis_project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1X_csJfIIyFkDga3A1axD7bSUR_dfJ4j-

# STEP 1: DATA PREVIEW AND CLEANING

## Step 1.1: Load the library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime as dt

!pip install squarify
import squarify

from google.colab import drive
drive.mount('/content/drive')

"""## Step 1.2: Load the csv"""

ecom_url = '/content/drive/MyDrive/Google Colab CSV/ecommerce-retail.csv'
# Read data frame from CSV file
ecom = pd.read_csv(ecom_url)
ecom

"""## Step 1.3: Check dataset info"""

ecom.info()

"""## Step 1.4: Check and clean columns that have null values
We found out that CustomerID column has null values in this case, let fix it in the next steps
"""

# Check null info
ecom.isnull().any()

# Drop null
ecom = ecom.dropna(subset=['CustomerID'])
ecom

# Check null info again
ecom.isnull().any()

"""## Step 1.5: Check data description and clean (if needed)
Check whether the data consists of any outliers
"""

ecom.describe()

"""Look like there is a negative min Quantity and UnitPrice equals to 0, which is not appropriate in this case. Let's exclude it."""

# Include rows from Quantity and UnitPrice column that are positive only
ecom = ecom[(ecom['Quantity'] > 0) & (ecom['UnitPrice'] > 0)]
ecom.describe()

"""# STEP 2: DATA WRANGLING

## Step 2.1: Filter columns required for analysis
"""

ecom = ecom[['CustomerID','InvoiceDate','InvoiceNo','Quantity','UnitPrice']]
ecom.head()

"""## Step 2.2: Calculate total value of each invoice"""

ecom["TotalRevenue"] = ecom["Quantity"] * ecom["UnitPrice"]
ecom.head()

"""## Step 2.3: Turn InvoiceDate, CustomerID to right format"""

ecom['InvoiceDate'] = pd.to_datetime(ecom['InvoiceDate'])
ecom['CustomerID'] = ecom['CustomerID'].astype(str)
ecom

"""# STEP 3: RFM CALCULATION

## Step 3.1: Calculate recency, monetary and frequency values group by CustomerID
"""

ecom_rfm = ecom.groupby("CustomerID").agg(
    {
        "InvoiceDate": lambda date: (dt.datetime(2011, 12, 31) - date.max()).days,
        "TotalRevenue": "sum",
        "InvoiceNo": "count",
    }
)

ecom_rfm

"""## Step 3.2: Change column names for clarity"""

new_ecom_rfm = ecom_rfm.rename(
    columns={
        "InvoiceDate": "Recency",
        "TotalRevenue": "Monetary",
        "InvoiceNo": "Frequency",
    }
)
new_ecom_rfm

"""## Step 3.3: Calcute RFM score based on quantile

Chỗ này xử lý khá là mượt
"""

def calculate_rfm_scores(data):
    # Calculate RFM scores using qcut with 5 labels
    data['R'] = pd.qcut(data['Recency'], q=5, labels=[5, 4, 3, 2, 1])
    data['F'] = pd.qcut(data['Frequency'], q=5, labels=[1, 2, 3, 4, 5])
    data['M'] = pd.qcut(data['Monetary'], q=5, labels=[1, 2, 3, 4, 5])

    # Calculate overall RFM score
    data['RFMScore'] = data['R'].astype(str) + data['F'].astype(str) + data['M'].astype(str)
    data['RFMScore'] = data['RFMScore'].astype(int)
    return data


new_ecom_rfm = calculate_rfm_scores(new_ecom_rfm)
new_ecom_rfm

"""## Step 3.4: Segment the customers based on their RFM Scores"""

# Read the segment file
segment = pd.read_excel('/content/drive/MyDrive/Google Colab CSV/ecommerce retail.xlsx', sheet_name = 1)

# Split the RFM Score column into each row
segment['RFM Score'] = segment['RFM Score'].str.split(',')
segment = segment.explode('RFM Score').reset_index(drop=True)
segment['RFM Score']=segment['RFM Score'].astype(int)
segment.sort_values(by='RFM Score')

# Join the segment table with new_ecom_rfm table with left join
new_ecom_rfm = new_ecom_rfm.merge(segment,how = 'left', left_on = 'RFMScore',right_on ='RFM Score')
new_ecom_rfm = new_ecom_rfm.dropna()
new_ecom_rfm

"""# STEP 4: VISUALIZATION & RECOMMENDATION

## Step 4.1: Visualize distribution of RFM
"""

# Set the style and color palette
sns.set_style('whitegrid')
palette_color = ['#ff9999', '#66b3ff', '#99ff99', '#ffcc99']

# Create a figure with three subplots
fig, axes = plt.subplots(1, 3, figsize=(16, 5))

# Plot the distribution of Recency
sns.histplot(new_ecom_rfm['R'], ax=axes[0], bins=5, color=palette_color[0])
axes[0].set_title('Distribution of Recency')
axes[0].set_xlabel('')
axes[0].set_ylabel('Count')

# Plot the distribution of Frequency
sns.histplot(new_ecom_rfm['F'], ax=axes[1], bins=5, color=palette_color[1])
axes[1].set_title('Distribution of Frequency')
axes[1].set_xlabel('')
axes[1].set_ylabel('')


# Plot the distribution of Monetary
sns.histplot(new_ecom_rfm['M'], ax=axes[2], bins=5, color=palette_color[2])
axes[2].set_title('Distribution of Monetary')
axes[2].set_xlabel('')
axes[2].set_ylabel('')


# Display the plot
plt.show()

"""## Step 4.2: Visualize treemap of RFM"""

colors = ['#91DCEA', '#64CDCC','#F6511D','#FFB400','#7FB800','#F7EF99','#5D675B','#F5F3F5','#9593D9','#F7E1D7','#00C49A']
fig, ax = plt.subplots(1, figsize=(15,8))
# Calculate the portion of each segment
segment_counts = new_ecom_rfm['Segment'].value_counts()
portion = segment_counts / segment_counts.sum()

# Calculate the percentage for each segment and round it to 1-2 decimal points
percentage = portion * 100.0
percentage = percentage.round(2)

# Create labels with segment names and percentages
labels = [f"{segment}\n{percent:.2f}%" for segment, percent in zip(segment_counts.index, percentage)]

# Create the treemap
squarify.plot(sizes=percentage,
              label=labels,
              color=colors[:len(segment_counts)],
              alpha=0.6,
              bar_kwargs=dict(linewidth=2.4, edgecolor="white"),
              )


plt.title("Customer Segments Based on RFM Score",
          fontsize=16,
          pad=8,
          fontweight='bold'
)
plt.axis('off')
plt.show()

"""## Step 4.3: Recommendation

"""

recommendation = {
    'Segment Name': [
        'Hibernating customers (18.63%)', 'Champions (18.42%)', 'Potential Loyalist (11.85%)', 'At Risk (9.98%)',
        'Lost customers (9.77%)', 'Loyal (9.64%)', 'New Customers (6.98%)', 'Need Attention (5.23%)',
        'About To Sleep (4.40%)', 'Promising (3.09%)', 'Cannot Lose Them (2.01%)'
    ],
    'Characteristics': [
        'Low recency, low frequency, low monetary',
        'High recency, high frequency, high monetary',
        'Medium recency, medium frequency, medium monetary',
        'High recency, low frequency, high monetary',
        'Very low recency, low frequency, low monetary',
        'High recency, high frequency, high monetary',
        'High recency, low frequency, low monetary',
        'Medium recency, medium frequency, medium monetary',
        'Low recency, low frequency, low monetary',
        'High recency, low frequency, medium monetary',
        'Low recency, low frequency, high monetary'
    ],
    'Recommendations': [
        'Reactivate with targeted campaigns to this segment since it takes the most portion',
        'Reward loyalty, upsell, cross-sell more to this segment since it takes the second place',
        'Nurture with personalized offers, this segment takes top 3',
        'Engage to prevent churn, top 4 in the portion should not be overlooked',
        'Winback with attractive offers with the top 5 segment',
        'Maintain satisfaction, upsell, cross-sell',
        'Welcome and onboard effectively',
        'Provide incentives to increase purchases',
        'Reactivate before they churn',
        'Convert to loyal customers',
        'Retain with exceptional service'
    ]
}

# Create the DataFrame
recommendation = pd.DataFrame(recommendation)
recommendation

"""# Conclusion

Nhìn chung, sự tương quan giữa ba chỉ số Recency, Frequency, Monetary tương quan nhau rất rõ rệt trong trường hợp này (nếu 1 trong 3 chỉ số tích cực thì sẽ tác động 2 chỉ số còn lại và ngược lại). Ngoài ra, lượng phân bổ của 3 chỉ số trên cũng rất cân bằng cho thấy tập khách hàng của doanh nghiệp đều trải dài đều nhau qua các segment.

Một vài đề xuất để phát triển nhóm top khách hàng của SuperStore như sau:

*   **Nhóm Champions** : Tập trung duy trì với nhóm khách hàng trên, liên tục engage với họ với các ưu đãi, đem đến cho họ những khuyến mãi thiết kế đặc biệt cho họ để thúc giục họ quay lại mua hàng đều đặn
*  **Nhóm Potential Loyalist**: Kích thích nhóm khách hàng này quay lại mua hàng để khiến họ trở thành nhóm Champions vì RFM tương quan, chỉ cần tác động tích cực tới chỉ số R hoặc F (bằng các đưa ra các ưu đãi, sự kiện hấp dẫn, hỗ trợ tốt trong dịch vụ khách hàng khi mua hàng), khả năng cao sẽ tác động tích cực đến 2 yếu tố còn lại (M và R hoặc M và F).
*  **Nhóm Hibernating customers**: Tái kích hoạt tương tác mua hàng thông qua khuyến mãi, marketing, sales đa kênh, từ đó làm phát triển lại awareness của nhóm khách hàng này về các sản phẩm và ưu đãi mới. Từng bước phát triển mối quan hệ với họ, để họ thường xuyên tiêu dùng vì đây không phải là nhóm khách hàng đổ dồn nhiều tiền vào một lần mua mà cần có nhiều kiên nhẫn để tạo mối liên kết mua hàng bền vững.  

Cuối cùng, các **nhóm khách hàng khác** cũng không được ngó lơ, **mục tiêu là khiến họ có tương tác mua hàng thường xuyên và liên tục** trong một thời gian, điều đó sẽ ảnh hưởng rất nhiều đến doanh thu của công ty. Đối với phòng ban Marketing, lời khuyên là nên tạo ra những chiến lược tiếp thị thật sự thu hút và bắt kịp xu hướng (video, quiz,...) để thúc đẩy việc mua hàng.
"""